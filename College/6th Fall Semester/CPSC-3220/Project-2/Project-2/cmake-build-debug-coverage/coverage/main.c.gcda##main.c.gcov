        -:    0:Source:C:/Users/Gavin T McRoy/Documents/GitHub/School-Rep/Project-2/main.c
        -:    0:Graph:C:\Users\Gavin T McRoy\Documents\GitHub\School-Rep\Project-2\cmake-build-debug-coverage\CMakeFiles\Project_2.dir\main.c.gcno
        -:    0:Data:C:\Users\Gavin T McRoy\Documents\GitHub\School-Rep\Project-2\cmake-build-debug-coverage\CMakeFiles\Project_2.dir\main.c.gcda
        -:    0:Runs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <limits.h>
        -:    5:#include "sched.h"
        -:    6:
        -:    7:/*  ./a.out <scheduling> <input> <outfile> */
function main called 1 returned 0% blocks executed 56%
        1:    8:int main(int args, char *argv[]) {
        1:    9:    const int EXPECTED_ARGS = 4;
        1:   10:    struct task *head = NULL;
        1:   11:    if (args < EXPECTED_ARGS) {
        1:   11-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   12:        exit(1);
    %%%%%:   12-block  0
call    0 never executed
        -:   13:    }
        1:   14:    char *schedule = argv[1];
        1:   15:    char *inputFile = argv[2];
        1:   16:    char *outputFile = argv[3];
        -:   17:
        1:   18:    int scheduleNumber = validScheduleName(schedule);
        1:   18-block  0
call    0 returned 1
        1:   19:    if (!scheduleNumber) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   20:        exit(1);
    %%%%%:   20-block  0
call    0 never executed
        -:   21:    }
        -:   22:
        1:   23:    head = loadInput(inputFile);
        1:   23-block  0
call    0 returned 0
    #####:   24:    runScheduler(scheduleNumber, head);
call    0 never executed
        -:   25:    //printFinalResult("FIFO scheduling results\n\n");
        -:   26:
        -:   27:}
        -:   28:
        -:   29:/* Ensures proper schedule names are passed in. */
function validScheduleName called 1 returned 100% blocks executed 50%
        1:   30:int validScheduleName(char *scheduleInput) {
        1:   31:    if (strcmp(scheduleInput, FIFO_NAME) == 0) {
        1:   31-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:   32:        //printf("FIFO_NAME \n");
    #####:   33:        return FIFO_SCHED;
    %%%%%:   33-block  0
        1:   34:    } else if (strcmp(scheduleInput, SJF_NAME) == 0) {
        1:   34-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:   35:        // printf("SJF_NAME \n");
    #####:   36:        return SJF_SCHED;
    %%%%%:   36-block  0
        1:   37:    } else if (strcmp(scheduleInput, RR_NAME) == 0) {
        1:   37-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:   38:        // printf("RR_NAME \n");
        1:   39:        return RR_SCHED;
        1:   39-block  0
        -:   40:    } else {
    #####:   41:        fprintf(stderr, "Error invalid scheduling option. Did you include \"-\" (Ex. -fifo not fifo) \n");
    %%%%%:   41-block  0
call    0 never executed
call    1 never executed
    #####:   42:        return 0;
        -:   43:    }
        -:   44:}
        -:   45:
function loadInput called 1 returned 0% blocks executed 40%
        1:   46:struct task *loadInput(char *in) {
        1:   47:    struct task *head = NULL;
        1:   48:    FILE *inFile = fopen(in, "r+");
        1:   48-block  0
call    0 returned 1
        1:   49:    if (!inFile) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   50:        fprintf(stderr, "Error invalid input file\n");
        1:   50-block  0
call    0 returned 1
call    1 returned 1
        1:   51:        exit(1);
call    0 returned 0
        -:   52:    }
    #####:   53:    int arrival = 0;
    #####:   54:    int service = 0;
        -:   55:
        -:   56:    /* we build the link list and read in all the data */
    #####:   57:    bool first = true;
    #####:   58:    struct task *temp = NULL;
    #####:   59:    int startLetter = 'A';
    #####:   60:    while (fscanf(inFile, "%d %d", &arrival, &service) != EOF) {
    %%%%%:   60-block  0
    %%%%%:   60-block  1
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   61:        struct task *node = (struct task *) malloc(sizeof(struct task));
    #####:   62:        node->arrival_time = arrival;
    #####:   63:        node->service_time = service;
    #####:   64:        node->task_id = startLetter;
    #####:   65:        node->isProcessed = false;
    #####:   66:        node->addedToQueue = false;
    #####:   67:        if (first) {
    %%%%%:   67-block  0
branch  0 never executed
branch  1 never executed
    #####:   68:            head = node;
    #####:   69:            temp = node;
    #####:   70:            first = false;
    %%%%%:   70-block  0
        -:   71:        } else {
    #####:   72:            temp->next = node;
    #####:   73:            temp = node;
    #####:   74:            node->next = NULL;
    %%%%%:   74-block  0
        -:   75:        }
    #####:   76:        startLetter++;
    %%%%%:   76-block  0
        -:   77:    }
        -:   78:
    #####:   79:    fclose(inFile);
    %%%%%:   79-block  0
call    0 never executed
    #####:   80:    return head;
        -:   81:}
        -:   82:
        -:   83:/* TODO implement function (prints final result to file in proper format) */
function saveFile called 0 returned 0% blocks executed 0%
    #####:   84:void saveFile(char *out) {
    #####:   85:    FILE *open = fopen(out, "w+");
    %%%%%:   85-block  0
call    0 never executed
    #####:   86:    fprintf(open, "testing output");
call    0 never executed
    #####:   87:}
        -:   88:
        -:   89:/* TODO implement function (chooses which scheduler to run)*/
function runScheduler called 0 returned 0% blocks executed 0%
    #####:   90:void runScheduler(int schedule, struct task *head) {
    #####:   91:    if (schedule == FIFO_SCHED) {
    %%%%%:   91-block  0
branch  0 never executed
branch  1 never executed
    #####:   92:        FIFO(head);
    %%%%%:   92-block  0
call    0 never executed
    #####:   93:    } else if (schedule == SJF_SCHED) {
    %%%%%:   93-block  0
branch  0 never executed
branch  1 never executed
    #####:   94:        SJF(head);
    %%%%%:   94-block  0
call    0 never executed
    #####:   95:    } else if (schedule == RR_SCHED) {
    %%%%%:   95-block  0
branch  0 never executed
branch  1 never executed
    #####:   96:        RR(head);
    %%%%%:   96-block  0
call    0 never executed
        -:   97:    }
    #####:   98:}
        -:   99:
        -:  100://time  cpu ready queue (tid/rst)
function printFinalResult called 0 returned 0% blocks executed 0%
    #####:  101:void printFinalResult(char *scheduleName) {
        -:  102:    /* First table template */
    #####:  103:    printf("%s", scheduleName);
    %%%%%:  103-block  0
call    0 never executed
    #####:  104:    printf("%-6s %-4s %-6s %-6s (tid/rst)\n", "time", "cpu", "ready", "queue");
call    0 never executed
    #####:  105:    printf("-------------------------------\n");
call    0 never executed
    #####:  106:    printf("%3d %5s %5s\n", 0, "AB", "--");
call    0 never executed
        -:  107:
        -:  108:    /* Second table template */
    #####:  109:    printf("\n\n");
call    0 never executed
    #####:  110:    printf("%14s %9s %12s %9s %5s", "arrival", "service", "completion", "response", "wait");
call    0 never executed
    #####:  111:    printf("\n");
call    0 never executed
    #####:  112:    printf("%-6s %-9s %-9s %-11s %-9s %-9s\n", "tid", "time", "time", "time", "time", "time");
call    0 never executed
    #####:  113:    printf("--------------------------------------------------\n");
call    0 never executed
        -:  114:
    #####:  115:}
        -:  116:
        -:  117:/* TODO Finish formatting */
function FIFO called 0 returned 0% blocks executed 0%
    #####:  118:void FIFO(struct task *head) {
        -:  119:    /* We need to loop through all the work */
    #####:  120:    int time = 0;
    #####:  121:    for (struct task *begin = head; begin != NULL; begin = begin->next) {
    %%%%%:  121-block  0
    %%%%%:  121-block  1
    %%%%%:  121-block  2
branch  0 never executed
branch  1 never executed
        -:  122:        /* We have a task, we now are searching for its start time */
    #####:  123:        bool startProcessing = false;
    #####:  124:        int conditionCount = begin->service_time;
        -:  125:        /* This loop must break once the schedule is complete. We need to build a run queue */
    #####:  126:        for (; time < INT_MAX; time++) {
    %%%%%:  126-block  0
    %%%%%:  126-block  1
    %%%%%:  126-block  2
branch  0 never executed
branch  1 never executed
        -:  127:            /* this prevents an extra new line in the beginning */
    #####:  128:            if (time == 0) {
    %%%%%:  128-block  0
branch  0 never executed
branch  1 never executed
    #####:  129:                printf("%d ", time);
    %%%%%:  129-block  0
call    0 never executed
        -:  130:            } else {
    #####:  131:                printf("\n%d ", time);
    %%%%%:  131-block  0
call    0 never executed
        -:  132:            }
        -:  133:            /* is the time moment at which it arrives, service time is run length */
        -:  134:
        -:  135:            /* Once our arrival times match we begin processing. TODO this is prone to bugs */
    #####:  136:            if (begin->arrival_time <= time) {
    %%%%%:  136-block  0
branch  0 never executed
branch  1 never executed
    #####:  137:                startProcessing = true;
    %%%%%:  137-block  0
        -:  138:            }
        -:  139:
        -:  140:            /* We need to build a queue list for which tasks are queuing up */
    #####:  141:            if (startProcessing) {
    %%%%%:  141-block  0
branch  0 never executed
branch  1 never executed
        -:  142:                /* Task then begins processing */
    #####:  143:                begin->isProcessed = true;
    #####:  144:                printf(" %c%d", begin->task_id, conditionCount);
    %%%%%:  144-block  0
call    0 never executed
        -:  145:
        -:  146:                /* We need to figure out the queue list */
    #####:  147:                for (struct task *queue = begin; queue != NULL; queue = queue->next) {
    %%%%%:  147-block  0
    %%%%%:  147-block  1
branch  0 never executed
branch  1 never executed
    #####:  148:                    if (queue->arrival_time <= time && !queue->isProcessed) {
    %%%%%:  148-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  148-block  1
branch  2 never executed
branch  3 never executed
    #####:  149:                        printf(" %c%d", queue->task_id, queue->service_time);
    %%%%%:  149-block  0
call    0 never executed
        -:  150:                    }
        -:  151:                }
        -:  152:
    #####:  153:                if (conditionCount == 1) {
    %%%%%:  153-block  0
branch  0 never executed
branch  1 never executed
    #####:  154:                    startProcessing = false;
        -:  155:                    /* This is confusing to explain, but the loop will terminate before time is incremented.
        -:  156:                     * This ensures time is incremented even when the loop closes, since its counter must not
        -:  157:                     * be reset */
    #####:  158:                    time++;
    #####:  159:                    break;
    %%%%%:  159-block  0
        -:  160:                }
    #####:  161:                conditionCount -= 1;
    %%%%%:  161-block  0
        -:  162:            }
        -:  163:        }
        -:  164:    }
    #####:  165:}
        -:  166:
        -:  167:/* This is preemptive so this might take some creativity */
function SJF called 0 returned 0% blocks executed 0%
    #####:  168:void SJF(struct task *head) {
        -:  169:    /* This is essentially an infinite loop */
    #####:  170:    for (int time = 0; time < INT_MAX; time++) {
    %%%%%:  170-block  0
    %%%%%:  170-block  1
    %%%%%:  170-block  2
branch  0 never executed
branch  1 never executed
        -:  171:        /* if everything is finished, break */
    #####:  172:        if (isFinished(head)) {
    %%%%%:  172-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  173:            break;
    %%%%%:  173-block  0
        -:  174:        }
        -:  175:        /* Solely for formatting */
    #####:  176:        if (time == 0) {
    %%%%%:  176-block  0
branch  0 never executed
branch  1 never executed
    #####:  177:            printf("%d", time);
    %%%%%:  177-block  0
call    0 never executed
        -:  178:        } else {
    #####:  179:            printf("\n%d", time);
    %%%%%:  179-block  0
call    0 never executed
        -:  180:        }
        -:  181:
        -:  182:        /* We find the shortest job */
    #####:  183:        struct task *optimalJob = SJF_pickOptimalJob(time, head);
    %%%%%:  183-block  0
call    0 never executed
        -:  184:
        -:  185:        /* We found an optimal job, so process one tick */
    #####:  186:        if (optimalJob) {
branch  0 never executed
branch  1 never executed
        -:  187:            /* Print the id + service, and queued jobs behind it */
    #####:  188:            printf(" %c%d", optimalJob->task_id, optimalJob->service_time);
    %%%%%:  188-block  0
call    0 never executed
    #####:  189:            SJF_buildQueue(time, head, optimalJob);
call    0 never executed
        -:  190:            /* If this job is finished, mark it as finished, else tick by one */
    #####:  191:            optimalJob->service_time--;
    #####:  192:            if (optimalJob->service_time == 0) {
branch  0 never executed
branch  1 never executed
    #####:  193:                optimalJob->isProcessed = true;
    %%%%%:  193-block  0
        -:  194:            }
        -:  195:        }
        -:  196:    }
    #####:  197:}
        -:  198:
        -:  199:/* When given start time, it will search for an optimal job, if no job is found returns null */
function SJF_pickOptimalJob called 0 returned 0% blocks executed 0%
    #####:  200:struct task *SJF_pickOptimalJob(int time, struct task *head) {
        -:  201:    /* Search the entire data structure */
    #####:  202:    struct task *optimalJob = NULL;
    #####:  203:    for (struct task *begin = head; begin != NULL; begin = begin->next) {
    %%%%%:  203-block  0
    %%%%%:  203-block  1
    %%%%%:  203-block  2
branch  0 never executed
branch  1 never executed
        -:  204:        /* This means a possible task has been found. But we must ensure it's the shortest task and unfinished */
    #####:  205:        if (begin->arrival_time <= time && !begin->isProcessed) {
    %%%%%:  205-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  205-block  1
branch  2 never executed
branch  3 never executed
        -:  206:            /* We need to then ensure this job is optimal. */
    #####:  207:            if (!optimalJob) {
    %%%%%:  207-block  0
branch  0 never executed
branch  1 never executed
    #####:  208:                optimalJob = begin;
    %%%%%:  208-block  0
        -:  209:            }
        -:  210:            /* Locate the shortest service time */
    #####:  211:            for (struct task *i = begin; i != NULL; i = i->next) {
    %%%%%:  211-block  0
    %%%%%:  211-block  1
    %%%%%:  211-block  2
branch  0 never executed
branch  1 never executed
        -:  212:                /* If a job is within the proper arrival time and its service time  is shorter, its optimal */
    #####:  213:                if (i->arrival_time <= time && optimalJob->service_time > i->service_time && !i->isProcessed) {
    %%%%%:  213-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  213-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  213-block  2
branch  4 never executed
branch  5 never executed
    #####:  214:                    optimalJob = i;
    %%%%%:  214-block  0
        -:  215:                }
        -:  216:            }
        -:  217:        }
        -:  218:    }
    #####:  219:    return optimalJob;
    %%%%%:  219-block  0
        -:  220:}
        -:  221:
        -:  222:/* TODO Queue not printing in correct order */
function SJF_buildQueue called 0 returned 0% blocks executed 0%
    #####:  223:void SJF_buildQueue(int time, struct task *head, struct task *optimal) {
    #####:  224:    optimal->addedToQueue = true;
        -:  225:    /* Search the entire data structure */
    #####:  226:    for (struct task *begin = head; begin != NULL; begin = begin->next) {
    %%%%%:  226-block  0
    %%%%%:  226-block  1
    %%%%%:  226-block  2
branch  0 never executed
branch  1 never executed
    #####:  227:        for (struct task *i = begin; i != NULL; i = i->next) {
    %%%%%:  227-block  0
    %%%%%:  227-block  1
    %%%%%:  227-block  2
branch  0 never executed
branch  1 never executed
        -:  228:            /* If a job is within the proper arrival time, not processed and not printed */
    #####:  229:            if ((i->arrival_time <= time) && !i->isProcessed && !i->addedToQueue && (begin->service_time >=
    %%%%%:  229-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  229-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  229-block  2
branch  4 never executed
branch  5 never executed
    #####:  230:                                                                                     i->service_time)) {
    %%%%%:  230-block  0
branch  0 never executed
branch  1 never executed
    #####:  231:                printf(" %c%d", i->task_id, i->service_time);
    %%%%%:  231-block  0
call    0 never executed
    #####:  232:                i->addedToQueue = true;
        -:  233:            }
        -:  234:        }
        -:  235:    }
        -:  236:    /* We then reset everything back to out of the queue */
    #####:  237:    for (struct task *begin = head; begin != NULL; begin = begin->next) {
    %%%%%:  237-block  0
    %%%%%:  237-block  1
branch  0 never executed
branch  1 never executed
    #####:  238:        begin->addedToQueue = false;
    %%%%%:  238-block  0
        -:  239:    }
    #####:  240:}
        -:  241:
        -:  242:
        -:  243:/* TODO go get lunch and implement round robin :D */
function RR called 0 returned 0% blocks executed 0%
    #####:  244:void RR(struct task *head) {
        -:  245:    struct task *process;
    #####:  246:    struct task *starter = head;
    #####:  247:    int counter = 0;
    #####:  248:    RR_setup(head);
    %%%%%:  248-block  0
call    0 never executed
        -:  249:    /* While it isn't finished, keep looping */
    #####:  250:    while (!isFinished(head)) {
    %%%%%:  250-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  251:        /* Once we go all the way through the list, restart at the beginning */
        -:  252:
        -:  253:        /* Solely for formatting */
    #####:  254:        if (counter == 0) {
    %%%%%:  254-block  0
branch  0 never executed
branch  1 never executed
    #####:  255:            printf("%d ", counter);
    %%%%%:  255-block  0
call    0 never executed
        -:  256:        } else {
    #####:  257:            printf("\n%d ", counter);
    %%%%%:  257-block  0
call    0 never executed
        -:  258:        }
        -:  259:
        -:  260:        /* TODO The problem with this is when it can't find another task, null is returned. It doesn't know
        -:  261:         * where it left off. */
    #####:  262:        process = RR_findNextTask(starter, counter);
    %%%%%:  262-block  0
call    0 never executed
        -:  263:        /* We found a task, tick by one, and give it a new starting location one in front which is
        -:  264:         * basically taking the previous task and placing it in the back, and moving everything else up by one */
    #####:  265:        if (process) {
branch  0 never executed
branch  1 never executed
    #####:  266:            printf("%c%d", process->task_id, process->service_time);
    %%%%%:  266-block  0
call    0 never executed
        -:  267:            /* tick by one */
    #####:  268:            process->service_time--;
    #####:  269:            starter = RR_smartPicker(starter);
call    0 never executed
        -:  270:        }
    #####:  271:        counter++;
    %%%%%:  271-block  0
        -:  272:    }
    #####:  273:}
        -:  274:
        -:  275:/* Round robin is 20x easier if it's just a circular list */
function RR_setup called 0 returned 0% blocks executed 0%
    #####:  276:void RR_setup(struct task *head) {
        -:  277:    struct task *begin;
        -:  278:    /* We are getting to the last element and then pointing it to the head creating a circular list*/
    #####:  279:    for (begin = head; begin != NULL; begin = begin->next) {
    %%%%%:  279-block  0
    %%%%%:  279-block  1
    %%%%%:  279-block  2
branch  0 never executed
branch  1 never executed
    #####:  280:        if (begin->next == NULL) {
    %%%%%:  280-block  0
branch  0 never executed
branch  1 never executed
    #####:  281:            break;
    %%%%%:  281-block  0
        -:  282:        }
        -:  283:    }
    #####:  284:    begin->next = head;
    #####:  285:    int check = 0;
    #####:  286:    for (begin = head; begin != NULL; begin = begin->next) {
    %%%%%:  286-block  0
    %%%%%:  286-block  1
    %%%%%:  286-block  2
branch  0 never executed
branch  1 never executed
    #####:  287:        if (begin == head) {
    %%%%%:  287-block  0
branch  0 never executed
branch  1 never executed
    #####:  288:            check++;
    %%%%%:  288-block  0
        -:  289:        }
    #####:  290:        if (check == 5) {
    %%%%%:  290-block  0
branch  0 never executed
branch  1 never executed
    #####:  291:            printf("Circle list created \n");
    %%%%%:  291-block  0
call    0 never executed
    #####:  292:            break;
        -:  293:        }
        -:  294:    }
    #####:  295:}
        -:  296:
        -:  297:/* Node cannot be null */
function RR_findNextTask called 0 returned 0% blocks executed 0%
    #####:  298:struct task *RR_findNextTask(struct task *node, int time) {
    #####:  299:    struct task *next = node->next;
    #####:  300:    int counter = 0;
    %%%%%:  300-block  0
        -:  301:    /* We assume we have a circular list, we basically go until we hit the beginning and search
        -:  302:     * for an optimal task. This allows us to begin at any point in the list */
        -:  303:    while (true) {
    #####:  304:        if (!next->isProcessed && next->arrival_time <= time) {
    %%%%%:  304-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  304-block  1
branch  2 never executed
branch  3 never executed
    #####:  305:            if (next->service_time == 0) {
    %%%%%:  305-block  0
branch  0 never executed
branch  1 never executed
    #####:  306:                next->isProcessed = true;
    #####:  307:                continue;
    %%%%%:  307-block  0
        -:  308:            }
    #####:  309:            return next;
    %%%%%:  309-block  0
        -:  310:        }
    #####:  311:        next = next->next;
        -:  312:
    #####:  313:        counter++;
        -:  314:        /* This means it cannot find a valid solution */
    #####:  315:        if (counter == 27) {
    %%%%%:  315-block  0
branch  0 never executed
branch  1 never executed
    #####:  316:            return NULL;
    %%%%%:  316-block  0
        -:  317:        }
        -:  318:    }
        -:  319:}
        -:  320:
function RR_smartPicker called 0 returned 0% blocks executed 0%
    #####:  321:struct task *RR_smartPicker(struct task *node) {
    #####:  322:    struct task *copy = node;
    #####:  323:    int counter = 0;
    %%%%%:  323-block  0
        -:  324:    /* cycle through elements and attempt to not pick itself*/
        -:  325:    while (true) {
        -:  326:        /* The only valid option is itself. */
    #####:  327:        if (counter == 27) {
    %%%%%:  327-block  0
branch  0 never executed
branch  1 never executed
    #####:  328:            return node;
    %%%%%:  328-block  0
        -:  329:        }
        -:  330:        /* If the node is not a copy, and its not processed, pick it since that means its the next valid answer */
    #####:  331:        if (node != copy && !node->isProcessed) {
    %%%%%:  331-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  331-block  1
branch  2 never executed
branch  3 never executed
    #####:  332:            return node;
    %%%%%:  332-block  0
        -:  333:        }
    #####:  334:        node = node->next;
    #####:  335:        counter++;
    %%%%%:  335-block  0
        -:  336:    }
        -:  337:}
        -:  338:
        -:  339:/* this is how we break out the infinite loop, if all tasks are processed return false */
function isFinished called 0 returned 0% blocks executed 0%
    #####:  340:bool isFinished(struct task *head) {
    #####:  341:    for (struct task *begin = head; begin != NULL; begin = begin->next) {
    %%%%%:  341-block  0
    %%%%%:  341-block  1
    %%%%%:  341-block  2
branch  0 never executed
branch  1 never executed
        -:  342:        /* if something is not processed, false */
    #####:  343:        if (!begin->isProcessed) {
    %%%%%:  343-block  0
branch  0 never executed
branch  1 never executed
    #####:  344:            return false;
    %%%%%:  344-block  0
        -:  345:        }
        -:  346:    }
        -:  347:    /* if everything is processed, true */
    #####:  348:    return true;
    %%%%%:  348-block  0
        -:  349:}
        -:  350:
        -:  351:/* if we want to destroy our data structure and reset as if the file was never read this is what we call */
function cleanUp called 0 returned 0% blocks executed 0%
    #####:  352:void cleanUp() {
        -:  353:
    #####:  354:}
        -:  355:
        -:  356:
        -:  357:
        -:  358://int time = 0;
        -:  359://for (struct task *begin = head; begin != NULL; begin = begin->next) {
        -:  360://// int temporaryStorage = begin->service_time;
        -:  361://for (; time < INT_MAX; time++) {
        -:  362:///* If this particular task has no remaining work, end */
        -:  363://if (begin->service_time == 0) {
        -:  364://break;
        -:  365://}
        -:  366://
        -:  367:///* This is solely for formatting */
        -:  368://if (time == 0) {
        -:  369://printf("%d ", time);
        -:  370://} else {
        -:  371://printf("\n%d ", time);
        -:  372://}
        -:  373://
        -:  374://
        -:  375://if (begin->arrival_time <= time) {
        -:  376://printf("%c%d", begin->task_id, begin->service_time);
        -:  377://begin->service_time--;
        -:  378://}
        -:  379://
        -:  380:///* if finished break */
        -:  381://}
        -:  382://}
