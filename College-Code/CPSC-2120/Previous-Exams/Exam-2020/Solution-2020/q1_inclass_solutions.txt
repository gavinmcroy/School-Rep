CpSc 2120 Fall 2020
Quiz 1 In-Class Part Solutions

1. Running Times (6 points)

(i) void john(int n) { while (n--); }
// Theta(n) -- it's just a loop counting down from n

(ii) void taylor(int n) { if(n) { taylor(n/2); } }
// Theta(log n) -- recursively steps n -> n/2 -> n/4...

(iii) void matthew(int n) { if(n) { john(n); matthew(n/2); } }
// Theta(n) -- unrolling the recursion gives running time
               n + n/2 + n/4 + ... <= 2n; similar to quickselect

(iv) void jacob(int n) { if(n) { john(n); jacob(n-1); } }
// Theta(n^2) --- unrolling recursion gives sum n+(n-1)+(n-2)+...,
                  similar to two nested "for" loops

(v) void tahj(int n) { if(n) { tahj(n-1); tahj(n-1); } }
// Theta(2^n) --- two calls to tahj(n-1) -> 4 calls to tahj(n-2) ->
                  8 calls to tahj(n-3) etc. 

(vi) void madison(int n) { if(n>=23) { madison(n/2); madison(n/2); } }
// Theta(n) --- similar to an inorder traversal.  The n>=23 just changes the
                base case / constant factor in the Theta() bound.


2. Predfind on a Linked List (6 points)

Node *predfind(Node *head, int V)
{
  if (head == NULL) return NULL;
  Node *n = predfind(head->next, V);
  if (head->key > V) return n;
  return (n==NULL || head->key >= n->key) ? head : n;  
}


3. Fall Colors (6 points)

SOL1: Sort the fall colors (say, with merge sort).  Traverse the BST
      (say, with an inorder traversal).  For each leaf encountered,
      binary search the fall colors to see if present. O(N log N).

SOL2: Store fall colors in a balanced BST T.  Traverse the binary tree
      given as input (say, with an inorder traversal).  For each leaf
      encountered, call find in T to see if present.  O(N log N).

SOL3: Store the fall colors in a hashtable H.  Traverse the binary
      tree given as input (say, with an inorder traversal).  For each
      leaf encountered, call find in H to see if present.  O(N)
      anticipated time (O(N) expected time using universal hashing).

SOL4: Sort the fall colors in O(N) time with radix sort.  Inorder
      traverse the BST to store only its leaves in a sorted sequence.
      Call "merge" from merge sort on this sequence (A) and the sorted
      sequence of fall colors (B).  Whenever the merge takes a string
      from A, check to make sure there's also an equal string in B
      available at the same point in the merge.  O(N).


4. Like 2150, But More Fun (6 points each part)

(a) Minecraft tic-tac-toe.

NOTE: We'll describe how to find the longest run where the 3rd coordinate
      is the one that changes; it's easy to run the same approach three
      times, appropriately modified, to check longest runs involving the
      other coordinates.

SOL1: Create an N x N x N array of ints and mark where the X's are with
      1s.  Loop over the array to count up the longest run -- there
      are several ways to do this (e.g., see the next few solutions),
      resulting in running times ranging from O(N^3) to O(N^4).

SOL2: Store the N positions of the X's in a hash table.  Loop over all
      N of these positions.  For each one (say, position x, y, z), loop
      forward in j as long as position x, y, z+j also exists in our
      hash table.  Keep a running max of longest such run.  O(N^2)
      anticipated time.

SOL3: Store the N positions of the X's in a hash table.  Loop over all
      N of these positions.  For each one (say, position x, y, z)
      _such that x, y, z-1 does not already exist in the hash table_,
      loop forward in j as long as position x, y, z+j also exists in
      our hash table.  Keep a running max of longest such run.  O(N)
      anticipated time, since we only scan each run once.

SOL4: Sort the N positions of the X's by x, then by y, then by z,
      using stable counting sorts (somewhat like with radix sort).
      This groups any run of consecutive X's together where the z
      coordinates increment across each run, so then just scan the N
      positions and remember the longest such run.  O(N)

(c) Expanding tic-tac-toe.

NOTE: Let B = 2sqrt(N).  Observe that 1+2+...+B = B(B+1)/2 > N, so
      after B moves all the cells in the board would be full.  Hence,
      the total number of moves is at most B (i.e., total number of
      moves = O(sqrt(N)).

SOL1: Keep a running iteration count K, intially 1, and incremented
      with each move.  For each number x we see in the input, insert x
      and x+K-1 (the two endpoints of the current segment) into a
      balanced BST, right after checking if x's successor is less than
      x+K (if so, this run would overlap another existing run and the
      game ends).  O(sqrt(N) log N).

      (note: the tree size is at most sqrt(N), so operations on this
      tree run in O(log sqrt(N)) time, but log sqrt(N) = (1/2) log N,
      so we usually write O(log N) instead of O(log sqrt(N)), with the
      1/2 dissappearing as a hidden constant).

SOL2: Keep the same iteration counter K as in SOL1.  For each number x
      in the input (up to the first B such numbers), make an interval
      [x, x+K-1].  Run the solution from lab 5 on these intervals (with
      slight modifications) to count the number of crossings for each
      interval.  Then look for the interval with nonzero crossings
      appearing earliest in the input. O(sqrt(N) log N).
      

